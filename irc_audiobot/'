"use strict";
var parse = require('parse-link')
var shellescape = require('shell-escape');
const { exec } = require('child_process');
const fetch = (...args) => import('node-fetch').then(({default: fetch}) => fetch(...args));
var Meta = require('html-metadata-parser');
var chans = []
var fullLine
var joined = false
exports.__esModule = true;
exports.on = exports.message = exports.reply = exports.server = exports.Connect = exports.ƛ = void 0;
var types_1 = require("./types");
var Irc = require("./irc");
var State = {
    connection: types_1.None,
    auth: types_1.Some({
        server: process.argv[2],
        nick: process.argv[3],
        channel: process.argv[4]
    }),
    port: types_1.None,
    message: types_1.None,
    line: types_1.None,
    error: types_1.None,
    connected: false
};
function fixedEncodeURIComponent (str) {
  return encodeURIComponent(str).replace(/[!'()*]/g, escape);
}
function applyMany(context, applied) {
    applied.forEach(function (callback) {
        types_1.match(context.line, function (line) {
          callback.apply(line);
        }, function (_) {
            console.warn('context was insufficient');
        });
    });
}


function cowsay(msg, chan){
  let str = msg.substring(8)
  exec(shellescape(('cowsay ' + str).split(' ')), (error, stdout, stderr) => {
    stdout.split("\n").map(v=>{
      serverRaw('PRIVMSG ' + chan + ' : ' + v + "\r\n")
    })
  })
}

function makeShortLink(url, chan, extraText){

  exec('cd /var/www/html/shorty; php shorty.php ' + url.split(':http').join('http'), (error, stdout, stderr)=>{
    if (error) {
      console.log(`error: ${error.message}`)
      return
    }
    if (stderr) {
      console.log(`stderr: ${stderr}`)
      return
    }
    if(stdout){
      let shortLink = 'https://shorty.dweet.net/' + stdout.split("\n")[0] + extraText
      let send = shortLink
      serverRaw('PRIVMSG ' + chan + ' :' + send + "\r\n")
    }
  })
}

function ƛ(details, _, Error) {
    State.auth = types_1.Some(details);
    State.error = types_1.Some(Error);
}
exports.ƛ = ƛ;
function Connect(port) {
    State.port = types_1.Some(port);
    return function () {
        var execution = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            execution[_i] = arguments[_i];
        }
        try {
            Irc.connect(State).then(function (state) {
                types_1.match(State.connection, function (client) {
                    client.on('data', function async (data) {
                        State.line = types_1.Some(data.toString().split(/\r\n/)[0]);
												var d=data.toString()
                        console.log(d)
                        fullLine = d
                        if(d.indexOf('PING :')!==-1){
                          var key = d.substring(d.indexOf('PING :') + 6)
                          console.log('received PING... replying with PONG ' + key + "\n")
                          var response = 'PONG :' + key + "\r\n"
                          console.log('response: ' + response + "\n")
                          serverRaw(response)
                        }
												if(d.indexOf('End of /MOTD command')!==-1) {
                          setTimeout(function(){
                            if(!joined){
                              joined = true
                              serverRaw('PRIVMSG nickserv :identify nodie code57253' + "\r\n")
                              process.argv.map((v, i)=>{
                                setTimeout(function(){
                                  if(i > 3){
                                    chans = [...chans, v]
                                    serverRaw('JOIN ' + v + "\r\n")
                                    //serverRaw('PRIVMSG ' + v + ' :moo!' + "\r\n")
                                  }
                                }, 2000*(i+1))
                              })
                            }
                          }, 1000)
                        } else {
                          chans.map((q,j)=>{
                            let chan = q
                            let token = 'PRIVMSG ' + chan + ' :'
                            if(d.indexOf(token)!==-1){

                              var message = data.toString().match(/PRIVMSG \#\S+ :(.+)/);
                              if (message) {
                                message.input.split("\r\n").forEach(async (msg) =>{
                                  if(!msg) return
																	if(!msg.split(':').length || (msg.split(':').length>1 && msg.split(':')[1].split('!')[0].indexOf('audiobot')!==-1)) return
                                  let txtmsg = message[1]
                                  let dotCommand = txtmsg.indexOf('.') !== -1 ? txtmsg.toLowerCase().split('.')[1].split(' ')[0] : ''
                                  let l=false
                                  if(dotCommand =='wordle'){
                                    let params = txtmsg.toLowerCase().split(' ').filter(v=>v)
                                    let knownLetters = params[1]
                                    let placement = params[2]
                                    return
                                  }

                                  if(dotCommand == 'wavepic'){
                                    makeShortLink('https://wavepic.dweet.net/' + txtmsg.split(' ')[1], chan, " <- wavy version :D")
                                    return
                                  } else {
																		let done = false
                                    txtmsg.split(' ').map((v,i)=>{
                                      if(v.indexOf('https://wavepic')==-1 && v.toLowerCase().indexOf('https://')!== -1 && (v.toLowerCase().indexOf('.jpg')!==-1 || v.toLowerCase().indexOf('.png')!==-1 || v.toLowerCase().indexOf('.gif')!==-1)){
                                        console.log('https://wavepic.dweet.net/' + v, chan, " <- wavy version :D")
                                        makeShortLink('https://wavepic.dweet.net/' + v, chan, " <- wavy version :D")
																				done=true
                                      }
                                    })
																		if(done)return
                                  }
                                  
                                  if(dotCommand == 'cowsay'){
                                    cowsay(txtmsg, chan)
																		return
                                  }



                                  if((msg.toLowerCase()).indexOf(l='https://www.youtube.com')!==-1
                                    //|| (msg.toLowerCase().indexOf(l='https://music.youtube')!==-1
                                    || (msg.toLowerCase().indexOf(l='https://youtu.be')!==-1
                                    )){

                                      let sendData = {playlist: chan.split('').filter(v=>v!=='#').join('')}
                                      const response = await fetch('https://audiobot.dweet.net/create.php', {
                                        method: 'post',
                                        body: JSON.stringify(sendData),
                                        headers: {'Content-Type': 'application/json'}
                                      });
                                      const data = await response.json();
                                      if(data[0]){
                                        let link = ((msg.substring(msg.indexOf(l)).trim())).split(' ')[0]
    
                                        l=''
                                        //serverRaw('PRIVMSG ' + channel + ' :' + link + "\r\n")
                                        if((l=link.split('?')).length){
                                          l=l.filter(v=>v.indexOf('v=')!==-1)
                                          if(l.length) l=l[l.length-1].split('v=')[1].split('&')[0]
                                        }
                                        if(!l || !l[0]){
                                          l=link.split('/')
                                          l=l[l.length-1]
                                        }
                                        let videoID = l
                                        //serverRaw('PRIVMSG ' + channel + ' :' + videoID.length + "\r\n")
  
                                        if(videoID.length >= 8 && videoID.length <=15){
                                          exec("php addTrack.php " + videoID + ' ' + chan.split('').filter(v=>v!='#').join(''), (error, stdout, stderr) => {
                                            if (error) {
                                              console.log(`error: ${error.message}`)
                                              return
                                            }
                                            if (stderr) {
                                              console.log(`stderr: ${stderr}`)
                                              return
                                            }
                                            if(stdout){
                                              let res = JSON.parse(stdout)
    
                                              exec('cd /var/www/html/shorty; php shorty.php ' +  'https://audiobot.dweet.net/'+chan.split('').filter(v=>v!='#').join('')+'/t/' + fixedEncodeURIComponent(res[1]), (error, stdout, stderr)=>{
                                                if (error) {
                                                  console.log(`error: ${error.message}`)
                                                  return
                                                }
                                                if (stderr) {
                                                  console.log(`stderr: ${stderr}`)
                                                  return
                                                }
                                                if(stdout){
                                                  let shortLink = 'https://shorty.dweet.net/' + stdout.split("\n")[0]
                                                  let send = shortLink + '   <-- audio only (normalized) for https://youtu.be/' + l
                                                  serverRaw('PRIVMSG ' + chan + ' :' + send + "\r\n")
                                                }
                                              })
                                            } else {
                                              console.log('word not found :(')
                                            }
                                          })
                                        }
                                      }
                                    }
                                })
                              }
                            }
                          })
                        }
                       // var message = data.toString().match(/PRIVMSG \#\S+ :(.+)/);
                       // if (message) {
                       //     State.message = types_1.Some(message[1].trim());
                       // }
                        //applyMany(State, execution);
                    });
                }, function (_) {
                    throw new ReferenceError('Failed to connect');
                });
            });
        }
        catch (e) {
            types_1.match(State.error, function (call) { return call(); }, function (_) {
                console.error('Uh oh ⚡️', e);
            });
        }
    };
}
exports.Connect = Connect;
function server(prefix, response) {
    return types_1.match(State.connection, function (connection) {
        return connection.write(prefix[0] + " :" + response + "\r\n");
    }, function (_) { return false; });
}
exports.server = server;
function serverRaw(response) {
    return types_1.match(State.connection, function (connection) {
        return connection.write(response + "\r\n");
    }, function (_) { return false; });
}
exports.server = serverRaw
function reply(response, data, chan) {
    return types_1.match(State.connection, function (connection) {
        var where = types_1.match(State.auth, function (credentials) { return credentials.channel; }, function () { return '##dslbottesting'; });
        return connection.write("PRIVMSG " + chan + " :" + (data || response) + "\r\n");
    }, function (_) { return false; });
}
exports.reply = reply;
function message(what) {
  //chans.map((v,i)=>{
  //  let chan = v
  //  let token = 'PRIVMSG ' + chan + ' :'
  //  if(line.indexOf(token)!==-1){
      return function (callback) {
          types_1.match(State.message, function (line) {
              if (what.test(line)) {
                  var capture = what.exec(line);
                  chans.map((v,i)=>{
                    let chan = v
                    let token = 'PRIVMSG ' + chan + ' :'
                    if(fullLine.indexOf(token)!==-1){
                      callback(capture ? capture[1] : line.split(/:/)[2], chan);
                      State.message = types_1.None;
                    }
                 })
              }
          }, function (_) { return false; });
      };
  //})
}
exports.message = message;
function on(what) {
    return function (callback) {
        types_1.match(State.line, function (line) {
              if (what.test(line)) {
                  var capture = what.exec(line);
                  callback(capture ? capture[1] : line.split(/:/)[2]);
              }
        }, function (_) {
            throw new ReferenceError('Connection not established');
        });
    };
}
exports.on = on;


